# 앱 개발에서 상태란?

## 상태의 정의
**UI를 결정하는 유동적인 데이터**

시간에 따라 변할 수 있고 그 변화가 ui에 영향을 주는 데이터
-> 현재 화면이 어떤 모습이어야 하는지를 결정하는 값

## flutter의 상태 관리
flutter는 선언형 ui를 사용하기 때문에 상태가 변하면 ui가 변함

즉 버튼을 눌렀으니 텍스트를 변경해야지가 아닌
현재 상태가 이러이러하니 화면을 이렇게 그려줘라고 동작함

## 상태가 아닌 것 vs 상태인 것

### 상태가 아닌 것
- 고정된 텍스트
- 항상 동일한 아이콘
- 변하지 않는 색상 값

시간이 지나도 바뀌지 않고 ui에 항상 동일하게 반영되기 때문에 상태가 아님

### 상태인 것
- 로그인 여부
- 로딩 중인지의 여부
- 장바구니에 담긴 상품 목록
- 사용자의 입력값

이 값들이 변하면 ui가 변하기 때문에 상태임

## 상태의 범위
이 상태가 바뀌면 어디까지 리빌드가 일어나야 하는가?
누가 이 상태를 알고 있어야 하는가? 를 정의 하는 개념

### 지역 상태 (Local State)
**특징**
하나의 위젯만 사용하는 상태
보통 StatefulWidget + setState()로 관리됨

**예시**
- 체크박스의 체크 여부
- 텍스트 필드의 입력값
- 다이얼로그의 열림/닫힘 여부

### 앱 상태 (Global / App State)
**특징**
앱 어디서나 접근 가능
여러 위젯이 함께 사용해야 하는 상태
화면이 바뀌어도 유지됨

**예시**
- 로그인 사용자
- 테마 (다크모드)
- 장바구니 목록

### 상태 범위를 잘 나누는 기준

✔ 이 상태는…

누가 쓰는가?
한 위젯 → Local
앱 전체 → Global

얼마나 오래 살아야 하는가?
잠깐 → Local
앱 실행 내내 → Global

UI 전용인가, 비즈니스 로직인가?
UI → 위젯 상태
로직 → 상태 관리 도구

## flutter에서 build()의 역할
build()는 상태를 기반으로 ui를 그리는 역할을 함
즉 상태가 변하면 build()가 호출되어 ui가 변함  

### 기본 흐름
1. 상태가 변한다
2. flutter는 이 위젯의 상태가 바뀌었다는 걸 인지한다
3. build() 메서드를 호출한다
4. 새로운 상태를 기반으로 위젯트리를 다시 만든다.
5. 실제로 변경된 부분이 화면에 반영된다.

이 때 설정을 잘 못 하거나 위젯 구조를 비효율적으로 짜면
아주 작은 데이터 하나만 바뀌었는데도 트리 상단의 부모 위젯부터
그 자식들까지 전부 build() 메서드가 다시 호출되는 성능 저하가 발생

이런 현상을 막기 위해 상태를 효율적으로 관리해야함

### 화면 전체가 리빌드되는 대표적인 이유

#### 1. setState()의 범위가 너무 넓을 때

setState()는 호출된 해당 State 객체가 속한 위젯의 build()를 통째로 다시 실행

나쁜 예: 화면 전체를 감싸는 Scaffold가 있는 위젯의 State에서 setState()를 호출하면
그 안에 있는 모든 텍스트, 이미지, 버튼들이 데이터 변경 여부와 상관없이 리빌드

해결책: 상태가 변하는 부분만 별도의 **작은 위젯(Small Widget)**으로 분리
그러면 그 작은 위젯의 setState()는 해당 위젯만 다시 그림

#### 2. 위젯 트리 상단에서 상태를 넘겨줄 때 (Prop Drilling)

부모 위젯이 상태를 가지고 있고, 저 밑에 있는 10번째 자식 위젯에게 데이터를 전달하기 위해 중간의 9개 위젯을 거쳐간다면?

상태가 바뀔 때 데이터를 전달해주는 중간 위젯들까지 전부 리빌드될 위험이 큼

