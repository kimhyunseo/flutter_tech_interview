# Riverpod 상태관리 패턴의 특징은 무엇인가요?
## Riverpod 상태관리 패턴이란?
Riverpod은 Flutter에서 상태를 위젯트리와 분리해서 관리하는
선언적 상태관리 라이브러리

> 선언적 상태 관리란? 
“어떻게” 할지를 쓰는 게 아니라
“무엇이 되어야 하는지”를 말하는 방식
(/ 명령형 상태관리: 어떻게 할지를 명시적으로 작성)

상태를 Provider라는 단위로 정의
위젯은 상태를 **구독(watch)**만 함
상태 변경 → 필요한 위젯만 자동 리빌드

## Riverpod 상태관리 패턴의 핵심 특징
### BuildContext에 의존하지 않음

기존 Provider
``` dart
Provider.of<Counter>(context);
```
Riverpod
``` dart
ref.watch(counterProvider);
```

위젯 트리 구조에 덜 의존
테스트, 리팩토링 쉬움
비 UI 코드에서도 상태 접근 가능

#### 기존 방식(Provider 등)에서 Context가 필수였던 이유
기존 Provider 작동 방식: `Provider.of<T>(context)`를 호출하면 현재 내 위치(context)를 기준으로 트리 위쪽으로 거슬러 올라가며 해당 타입의 데이터를 가진 부모를 찾음

- UI 밖에서 접근 불가: 위젯 트리와 상관없는 일반 클래스(Service, Repository 등)나 비즈니스 로직 코드 안에서는 context가 없어서 상태를 읽거나 변경하기가 매우 어렵습니다.

- 런타임 에러: 만약 트리 위쪽에 찾는 데이터가 없으면 앱이 실행 중에 튕겨버임

Flutter의 기존 방식은 상태에 접근하기 위해 항상 context가 필요했습니다.

Riverpod은 WidgetRef 또는 ProviderRef를 사용하여 context 없이도 어디서든 상태에 접근하고 읽을 수 있음

## 컴파일 타임 안전성
기존 Provider는 `Provider.of<T>(context)`를 사용할 때 해당 타입의 Provider가 위젯 트리 상단에 없으면 **런타임 에러**가 발생

Riverpod은 모든 Provider를 전역적으로 선언하고 ConsumerWidget을 통해 접근하므로, 런타임 에러 없이 컴파일 시점에 문제를 발견할 수 있습니다.

## 상태와 UI의 명확한 분리
- 상태: Provider / ViewModel
- UI: Widget
``` dart
final counterProvider = StateProvider<int>((ref) => 0);
Text('${ref.watch(counterProvider)}');
```
👉 위젯은 “어떻게 보여줄지만” 신경 씀

## 필요한 위젯만 리빌드된다
Riverpod은 어떤 provider를
어떤 위젯이 watch하고 있는지 추적
👉 상태 변경 시 해당 provider를 구독한 위젯만 리빌드
➡ 성능 최적화에 유리
